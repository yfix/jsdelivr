{"version":3,"file":"json-patch-duplex.min.js","sources":["../src/json-patch-duplex.js"],"names":["jsonpatch","_equals","a","b","_isArray","length","i","l","bKeys","_objectKeys","bLength","escapePathComponent","str","indexOf","replace","_getPathRecursive","root","obj","found","key","hasOwnProperty","getPath","path","Error","getMirror","ilen","beforeDict","getObserverFromMirror","mirror","callback","j","jlen","observers","observer","removeObserverFromMirror","splice","unobserve","generate","Object","observe","_unobserve","clearTimeout","next","patches","Mirror","push","arr","_observe","alen","name","object","type","observeOps","call","value","JSON","parse","stringify","intervals","this","currentInterval","dirtyCheck","fastCheck","setTimeout","slowCheck","window","addEventListener","attachEvent","ObserverInfo","v","deliverChangeRecords","_generate","temp","newKeys","oldKeys","changed","deleted","t","oldVal","newVal","op","isInteger","charCode","len","charCodeAt","apply","tree","patch","result","p","plen","keys","split","undefined","from","index","parseInt","arrOps","objOps","rootOps","compare","tree1","tree2","o","add","remove","move","copy","test","_get","delete","update","Array","isArray","exports"],"mappings":"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","sourcesContent":["/*!\n* json-patch-duplex.js 0.4.0\n* (c) 2013 Joachim Wester\n* MIT license\n*/\n\nvar jsonpatch;\n(function (jsonpatch) {\n    var _objectKeys = (function () {\n        if (Object.keys)\n            return Object.keys;\n\n        return function (o) {\n            var keys = [];\n            for (var i in o) {\n                if (o.hasOwnProperty(i)) {\n                    keys.push(i);\n                }\n            }\n            return keys;\n        };\n    })();\n\n    function _equals(a, b) {\n        switch (typeof a) {\n            case 'undefined':\n            case 'boolean':\n            case 'string':\n            case 'number':\n                return a === b;\n            case 'object':\n                if (a === null)\n                    return b === null;\n                if (_isArray(a)) {\n                    if (!_isArray(b) || a.length !== b.length)\n                        return false;\n\n                    for (var i = 0, l = a.length; i < l; i++)\n                        if (!_equals(a[i], b[i]))\n                            return false;\n\n                    return true;\n                }\n\n                var bKeys = _objectKeys(b);\n                var bLength = bKeys.length;\n                if (_objectKeys(a).length !== bLength)\n                    return false;\n\n                for (var i = 0; i < bLength; i++)\n                    if (!_equals(a[i], b[i]))\n                        return false;\n\n                return true;\n\n            default:\n                return false;\n        }\n    }\n\n    /* We use a Javascript hash to store each\n    function. Each hash entry (property) uses\n    the operation identifiers specified in rfc6902.\n    In this way, we can map each patch operation\n    to its dedicated function in efficient way.\n    */\n    /* The operations applicable to an object */\n    var objOps = {\n        add: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        remove: function (obj, key) {\n            delete obj[key];\n            return true;\n        },\n        replace: function (obj, key) {\n            obj[key] = this.value;\n            return true;\n        },\n        move: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"remove\", path: this.from }\n            ]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        copy: function (obj, key, tree) {\n            var temp = { op: \"_get\", path: this.from };\n            apply(tree, [temp]);\n            apply(tree, [\n                { op: \"add\", path: this.path, value: temp.value }\n            ]);\n            return true;\n        },\n        test: function (obj, key) {\n            return _equals(obj[key], this.value);\n        },\n        _get: function (obj, key) {\n            this.value = obj[key];\n        }\n    };\n\n    /* The operations applicable to an array. Many are the same as for the object */\n    var arrOps = {\n        add: function (arr, i) {\n            if (i > arr.length) {\n                throw new Error(\"The specified index MUST NOT be greater than the number of elements in the array.\");\n            }\n            arr.splice(i, 0, this.value);\n            return true;\n        },\n        remove: function (arr, i) {\n            arr.splice(i, 1);\n            return true;\n        },\n        replace: function (arr, i) {\n            arr[i] = this.value;\n            return true;\n        },\n        move: objOps.move,\n        copy: objOps.copy,\n        test: objOps.test,\n        _get: objOps._get\n    };\n\n    /* The operations applicable to object root. Many are the same as for the object */\n    var rootOps = {\n        add: function (obj) {\n            rootOps.remove.call(this, obj);\n            for (var key in this.value) {\n                if (this.value.hasOwnProperty(key)) {\n                    obj[key] = this.value[key];\n                }\n            }\n            return true;\n        },\n        remove: function (obj) {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    objOps.remove.call(this, obj, key);\n                }\n            }\n            return true;\n        },\n        replace: function (obj) {\n            apply(obj, [\n                { op: \"remove\", path: this.path }\n            ]);\n            apply(obj, [\n                { op: \"add\", path: this.path, value: this.value }\n            ]);\n            return true;\n        },\n        move: objOps.move,\n        copy: objOps.copy,\n        test: function (obj) {\n            return (JSON.stringify(obj) === JSON.stringify(this.value));\n        },\n        _get: objOps._get\n    };\n\n    var observeOps = {\n        add: function (patches, path) {\n            var patch = {\n                op: \"add\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name] };\n            patches.push(patch);\n        },\n        'delete': function (patches, path) {\n            var patch = {\n                op: \"remove\",\n                path: path + escapePathComponent(this.name)\n            };\n            patches.push(patch);\n        },\n        update: function (patches, path) {\n            var patch = {\n                op: \"replace\",\n                path: path + escapePathComponent(this.name),\n                value: this.object[this.name]\n            };\n            patches.push(patch);\n        }\n    };\n\n    function escapePathComponent(str) {\n        if (str.indexOf('/') === -1 && str.indexOf('~') === -1)\n            return str;\n        return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    function _getPathRecursive(root, obj) {\n        var found;\n        for (var key in root) {\n            if (root.hasOwnProperty(key)) {\n                if (root[key] === obj) {\n                    return escapePathComponent(key) + '/';\n                } else if (typeof root[key] === 'object') {\n                    found = _getPathRecursive(root[key], obj);\n                    if (found != '') {\n                        return escapePathComponent(key) + '/' + found;\n                    }\n                }\n            }\n        }\n        return '';\n    }\n\n    function getPath(root, obj) {\n        if (root === obj) {\n            return '/';\n        }\n        var path = _getPathRecursive(root, obj);\n        if (path === '') {\n            throw new Error(\"Object not found in root\");\n        }\n        return '/' + path;\n    }\n\n    var beforeDict = [];\n\n    jsonpatch.intervals;\n\n    var Mirror = (function () {\n        function Mirror(obj) {\n            this.observers = [];\n            this.obj = obj;\n        }\n        return Mirror;\n    })();\n\n    var ObserverInfo = (function () {\n        function ObserverInfo(callback, observer) {\n            this.callback = callback;\n            this.observer = observer;\n        }\n        return ObserverInfo;\n    })();\n\n    function getMirror(obj) {\n        for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n            if (beforeDict[i].obj === obj) {\n                return beforeDict[i];\n            }\n        }\n    }\n\n    function getObserverFromMirror(mirror, callback) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].callback === callback) {\n                return mirror.observers[j].observer;\n            }\n        }\n    }\n\n    function removeObserverFromMirror(mirror, observer) {\n        for (var j = 0, jlen = mirror.observers.length; j < jlen; j++) {\n            if (mirror.observers[j].observer === observer) {\n                mirror.observers.splice(j, 1);\n                return;\n            }\n        }\n    }\n\n    function unobserve(root, observer) {\n        generate(observer);\n        if (Object.observe) {\n            _unobserve(observer, root);\n        } else {\n            clearTimeout(observer.next);\n        }\n\n        var mirror = getMirror(root);\n        removeObserverFromMirror(mirror, observer);\n    }\n    jsonpatch.unobserve = unobserve;\n\n    function observe(obj, callback) {\n        var patches = [];\n        var root = obj;\n        var observer;\n        var mirror = getMirror(obj);\n\n        if (!mirror) {\n            mirror = new Mirror(obj);\n            beforeDict.push(mirror);\n        } else {\n            observer = getObserverFromMirror(mirror, callback);\n        }\n\n        if (observer) {\n            return observer;\n        }\n\n        if (Object.observe) {\n            observer = function (arr) {\n                //This \"refresh\" is needed to begin observing new object properties\n                _unobserve(observer, obj);\n                _observe(observer, obj);\n\n                var a = 0, alen = arr.length;\n                while (a < alen) {\n                    if (!(arr[a].name === 'length' && _isArray(arr[a].object)) && !(arr[a].name === '__Jasmine_been_here_before__')) {\n                        var type = arr[a].type;\n\n                        switch (type) {\n                            case 'new':\n                                type = 'add';\n                                break;\n\n                            case 'deleted':\n                                type = 'delete';\n                                break;\n\n                            case 'updated':\n                                type = 'update';\n                                break;\n                        }\n\n                        observeOps[type].call(arr[a], patches, getPath(root, arr[a].object));\n                    }\n                    a++;\n                }\n\n                if (patches) {\n                    if (callback) {\n                        callback(patches);\n                    }\n                }\n                observer.patches = patches;\n                patches = [];\n            };\n        } else {\n            observer = {};\n\n            mirror.value = JSON.parse(JSON.stringify(obj)); // Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n\n            if (callback) {\n                //callbacks.push(callback); this has no purpose\n                observer.callback = callback;\n                observer.next = null;\n                var intervals = this.intervals || [100, 1000, 10000, 60000];\n                if (intervals.push === void 0) {\n                    throw new Error(\"jsonpatch.intervals must be an array\");\n                }\n                var currentInterval = 0;\n\n                var dirtyCheck = function () {\n                    generate(observer);\n                };\n                var fastCheck = function () {\n                    clearTimeout(observer.next);\n                    observer.next = setTimeout(function () {\n                        dirtyCheck();\n                        currentInterval = 0;\n                        observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                    }, 0);\n                };\n                var slowCheck = function () {\n                    dirtyCheck();\n                    if (currentInterval == intervals.length)\n                        currentInterval = intervals.length - 1;\n                    observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n                };\n                if (typeof window !== 'undefined') {\n                    if (window.addEventListener) {\n                        window.addEventListener('mousedown', fastCheck);\n                        window.addEventListener('mouseup', fastCheck);\n                        window.addEventListener('keydown', fastCheck);\n                    } else {\n                        window.attachEvent('onmousedown', fastCheck);\n                        window.attachEvent('onmouseup', fastCheck);\n                        window.attachEvent('onkeydown', fastCheck);\n                    }\n                }\n                observer.next = setTimeout(slowCheck, intervals[currentInterval++]);\n            }\n        }\n        observer.patches = patches;\n        observer.object = obj;\n\n        mirror.observers.push(new ObserverInfo(callback, observer));\n\n        return _observe(observer, obj);\n    }\n    jsonpatch.observe = observe;\n\n    /// Listen to changes on an object tree, accumulate patches\n    function _observe(observer, obj) {\n        if (Object.observe) {\n            Object.observe(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _observe(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function _unobserve(observer, obj) {\n        if (Object.observe) {\n            Object.unobserve(obj, observer);\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    var v = obj[key];\n                    if (v && typeof (v) === \"object\") {\n                        _unobserve(observer, v);\n                    }\n                }\n            }\n        }\n        return observer;\n    }\n\n    function generate(observer) {\n        if (Object.observe) {\n            Object.deliverChangeRecords(observer);\n        } else {\n            var mirror;\n            for (var i = 0, ilen = beforeDict.length; i < ilen; i++) {\n                if (beforeDict[i].obj === observer.object) {\n                    mirror = beforeDict[i];\n                    break;\n                }\n            }\n            _generate(mirror.value, observer.object, observer.patches, \"\");\n        }\n        var temp = observer.patches;\n        if (temp.length > 0) {\n            observer.patches = [];\n            if (observer.callback) {\n                observer.callback(temp);\n            }\n        }\n        return temp;\n    }\n    jsonpatch.generate = generate;\n\n    // Dirty check if obj is different from mirror, generate patches and update mirror\n    function _generate(mirror, obj, patches, path) {\n        var newKeys = _objectKeys(obj);\n        var oldKeys = _objectKeys(mirror);\n        var changed = false;\n        var deleted = false;\n\n        for (var t = oldKeys.length - 1; t >= 0; t--) {\n            var key = oldKeys[t];\n            var oldVal = mirror[key];\n            if (obj.hasOwnProperty(key)) {\n                var newVal = obj[key];\n                if (oldVal instanceof Object) {\n                    _generate(oldVal, newVal, patches, path + \"/\" + escapePathComponent(key));\n                } else {\n                    if (oldVal != newVal) {\n                        changed = true;\n                        patches.push({ op: \"replace\", path: path + \"/\" + escapePathComponent(key), value: newVal });\n                        mirror[key] = newVal;\n                    }\n                }\n            } else {\n                patches.push({ op: \"remove\", path: path + \"/\" + escapePathComponent(key) });\n                delete mirror[key];\n                deleted = true; // property has been deleted\n            }\n        }\n\n        if (!deleted && newKeys.length == oldKeys.length) {\n            return;\n        }\n\n        for (var t = 0; t < newKeys.length; t++) {\n            var key = newKeys[t];\n            if (!mirror.hasOwnProperty(key)) {\n                patches.push({ op: \"add\", path: path + \"/\" + escapePathComponent(key), value: obj[key] });\n                mirror[key] = JSON.parse(JSON.stringify(obj[key]));\n            }\n        }\n    }\n\n    var _isArray;\n    if (Array.isArray) {\n        _isArray = Array.isArray;\n    } else {\n        _isArray = function (obj) {\n            return obj.push && typeof obj.length === 'number';\n        };\n    }\n\n    //3x faster than cached /^\\d+$/.test(str)\n    function isInteger(str) {\n        var i = 0;\n        var len = str.length;\n        var charCode;\n        while (i < len) {\n            charCode = str.charCodeAt(i);\n            if (charCode >= 48 && charCode <= 57) {\n                i++;\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n\n    /// Apply a json-patch operation on an object tree\n    function apply(tree, patches) {\n        var result = false, p = 0, plen = patches.length, patch;\n        while (p < plen) {\n            patch = patches[p];\n            p++;\n\n            // Find the object\n            var keys = patch.path.split('/');\n            var obj = tree;\n            var t = 1;\n            var len = keys.length;\n\n            if (patch.value === undefined && (patch.op === \"add\" || patch.op === \"replace\" || patch.op === \"test\")) {\n                throw new Error(\"'value' MUST be defined\");\n            }\n            if (patch.from === undefined && (patch.op === \"copy\" || patch.op === \"move\")) {\n                throw new Error(\"'from' MUST be defined\");\n            }\n\n            while (true) {\n                if (_isArray(obj)) {\n                    var index;\n                    if (keys[t] === '-') {\n                        index = obj.length;\n                    } else if (isInteger(keys[t])) {\n                        index = parseInt(keys[t], 10);\n                    } else {\n                        throw new Error(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\");\n                    }\n                    t++;\n                    if (t >= len) {\n                        result = arrOps[patch.op].call(patch, obj, index, tree); // Apply patch\n                        break;\n                    }\n                    obj = obj[index];\n                } else {\n                    var key = keys[t];\n                    if (key !== undefined) {\n                        if (key && key.indexOf('~') != -1)\n                            key = key.replace(/~1/g, '/').replace(/~0/g, '~'); // escape chars\n                        t++;\n                        if (t >= len) {\n                            result = objOps[patch.op].call(patch, obj, key, tree); // Apply patch\n                            break;\n                        }\n                    } else {\n                        t++;\n                        if (t >= len) {\n                            result = rootOps[patch.op].call(patch, obj, key, tree); // Apply patch\n                            break;\n                        }\n                    }\n                    obj = obj[key];\n                }\n            }\n        }\n        return result;\n    }\n    jsonpatch.apply = apply;\n\n    function compare(tree1, tree2) {\n        var patches = [];\n        _generate(tree1, tree2, patches, '');\n        return patches;\n    }\n    jsonpatch.compare = compare;\n})(jsonpatch || (jsonpatch = {}));\n\nif (typeof exports !== \"undefined\") {\n    exports.apply = jsonpatch.apply;\n    exports.observe = jsonpatch.observe;\n    exports.unobserve = jsonpatch.unobserve;\n    exports.generate = jsonpatch.generate;\n    exports.compare = jsonpatch.compare;\n}\n//# sourceMappingURL=json-patch-duplex.js.map\n"]}